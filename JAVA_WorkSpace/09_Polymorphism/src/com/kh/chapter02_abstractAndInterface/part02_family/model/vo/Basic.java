package com.kh.chapter02_abstractAndInterface.part02_family.model.vo;

public interface Basic {
	
	/*
	 * 인터페이스
	 * [표현법]
	 * [접근제한자] interface 인터페이스명 {}
	 * 
	 * - 상수 필드와 추상메서드로만 이루어진 "추상 클래스"의 변형체
	 * - 인터페이스에서 필드는 무조건 상수필드
	 * - 인터페이스에서 메서드는 무조건 추상메서드
	 * - 무조건 구현해야하는게 있을 때 인터페이스를 만들어서 상속하게 된다
	 * - 인터페이스는 다중상속(다중구현)을 허용한다 == 상속관계에 얽매여있지 않다
	 * 	(결국 메서드에 대한 정의만 하고있기 때문에 상속받은 메서드가 겹치더라도, 최종 구현부분은
	 * 	 구현 클래스에서 이루어질 것이기 때문에 다중상속이 가능힘)
	 * - 추상클래스와 다르게 더 강한 규칙성, 강제성을 가지는게 인터페이스이다
	 * 
	 * 추상클래스와 인터페이스
	 * 1. 공통점
	 * 	- 객체 생성은 안되나, 참조변수로써 사용이 가능하다 == 다형성을 적용할 수 있음
	 * 	- 상속(구현)하는 클래스에 추상메서드를 구현하도록 강제한다
	 * 
	 * 2. 차이점
	 * 	- 추상클래스는 클래스 내에 인스턴스 변수(필드), 메서드를 생성할 수 있고, 추상 메서드가 포함되어 있거나
	 * 	  abstact키워드로 클래스가 정의되어있고
	 * 	  인터페이스는 인스턴스변수(필드), 메서드 생성이 불가능하며, 모든 변수는 상수필드이고, 추상 메서드로만
	 *    정의되어 있다
	 *    
	 *  - 존재하는 목적이 다르다
	 *    추상클래스는 추상클래스를 상속받아서 기능을 이용하고, 클래스를 "확장"(상속)하는데 목적이 있고
	 *  
	 *    인터페이스는 클래스의 기능(함수)구현을 "강제"하기 위해서 사용된다. 즉, 구현을 강제함으로써
	 *    구현 객체의 "동일한 동작"을 보장할 수 있음
	 * 
	 * 		extends와 implements
	 * 		- 클래스간에 상속 관계일 때 : A클래스 extends 부모클래스
	 * 		- 클래스와 인터페이스의 구현관계일 때 : 클래스명 implements 인터페이스 , 인터페이스
	 * 		- 인터페이스와 인터페이스간의 상속관계 : 인터페이스명 extends 인터페이스명 , 인터페이스명(다중 상속가능)
	 */
	
	/* public static final */ int num = 10; // 값을 초기화 시키면 필드에 작성 가능
	// 인터페이스는 상수필드만 정의할 수 있기 때문에 앞에 public static final이 생략가눙
	
	/* public abstract */void eat();
	void sleep();
	
	// 인터페이스는 추상메서드만 정의할 수 있기 때문에 앞에 public abstract가 생략 가능
	
}
